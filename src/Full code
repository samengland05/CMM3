# Create an explicit polynomial equation for z_r(t)
# from the Gale terrain CSV file

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

# import data from csv
data = pd.read_csv("gale_terrain_synthetic.csv")

# columns for time and height
time_values = np.array(data["time_s"])
height_values = np.array(data["elevation_m"])

# make polynomial curve
# input polynomial order
poly_order = 6

# retun coefficients
poly_coeff = np.polyfit(time_values, height_values, poly_order)

# turn the coefficients into a callable polynomial object
z_r = np.poly1d(poly_coeff)

# display equation
print("\nApproximation for mars terrain profile z_r(t):\n")
print(z_r)

# to display polynomial neatly
print("\nPolynomial coefficients (a0 is constant term):")
for i, c in enumerate(poly_coeff[::-1]):
    print(f"a{i} = {c:.6e}")

# data plot against polynomial
# dnese time axis to smoothen curve 
t_plot = np.linspace(time_values.min(), time_values.max(), 800)

plt.figure(figsize=(8,4))
plt.scatter(time_values, height_values, s=12, color="black", label="Recorded data")
plt.plot(t_plot, z_r(t_plot), "r-", lw=1.8, label=f"Polynomial line (deg={poly_order})")
plt.xlabel("Time [s]")
plt.ylabel("Height [m]")
plt.title("Polynomial Curve of Mars Terrain z_r(t)")
plt.grid(True, ls="--", alpha=0.6)
plt.legend()
plt.tight_layout()
plt.show()

# Parameters (example Mars rover wheel suspension)
m = 50.0     # kg
k = 5413.71  # N/m
c = 400   # N·s/m

# External force (terrain bump)


# ODE system: y = [x, v]  (displacement, velocity)
def f(t, y):
    x, v = y
    y_t = terrain(t)          # terrain displacement at time t
    dy_dt = terrain_derivative(t)  # terrain velocity at time t
    a = (k*(y_t - x) + c*(dy_dt - v)) / m
    return np.array([v, a])

def terrain(t):
    return (-1.728e-17*(t**6) +
            1.02e-13*(t**5) -
            2.265e-10*(t**4) +
            2.336e-7*(t**3) -
            0.0001102*(t**2) +
            0.01905*t -
            0.1875)

def terrain_derivative(t):
    return (-1.728e-17*6*(t**5) +
             1.02e-13*5*(t**4) -
             2.265e-10*4*(t**3) +
             2.336e-7*3*(t**2) -
             0.0001102*2*t +
             0.01905)

# Runge-Kutta 4th order
def rk4(f, y0, t0, tf, dt):
    t = np.arange(t0, tf + dt, dt)
    y = np.zeros((len(t), len(y0)))
    y[0] = y0
    for i in range(1, len(t)):
        k1 = f(t[i-1], y[i-1])
        k2 = f(t[i-1] + dt/2, y[i-1] + dt*k1/2)
        k3 = f(t[i-1] + dt/2, y[i-1] + dt*k2/2)
        k4 = f(t[i-1] + dt, y[i-1] + dt*k3)
        y[i] = y[i-1] + (dt/6)*(k1 + 2*k2 + 2*k3 + k4)
    return t, y

# Initial conditions
y0 = np.array([0.0, 0.0])  # x0=0, v0=0
t0, tf, dt = 0.0, 1000.0, 0.1

# Solve
t, y = rk4(f, y0, t0, tf, dt)
x, v = y.T

# Plot displacement
plt.figure(figsize=(9,5))
plt.plot(t, x)
plt.title("Mars Rover Suspension (1D)")
plt.xlabel("Time [s]")
plt.ylabel("Displacement [m]")
plt.grid(True)
plt.xticks(np.arange(0, 1100, 100)) 
plt.show()

def max_displacement(k):
    def f(t,y):
        x, v =y
        a=(F(t)-c*v-k*x)/m 
        return np.array([v,a])
    t, y=rk4(f, np.array([0.0,0.0]),0.0, 5.0, 0.001)
    x, _=y.T
    return np.max(np.abs(x))
    

def F(t):
    if 1.0<=t<=1.2:
        return 330.0*np.sin(np.pi*(t-1)/0.17)
    else: 
        return 0.0


def objective(k):
    return max_displacement(k)-0.025


def secant(f,x0,x1,tol=1e-6, N=50):
    for i in range(N):
        f0,f1=f(x0), f(x1)
        if f1-f0==0:
            print ("Division by 0 encountered")
            return None
        x2=x1-f1*(x1-x0)/(f1-f0)
        print(f"Iteration {i+1}:k={x2:.2f},f(k)={f(x2):.6f}")
        if abs(x2-x1)<tol:
            print("Convergred!")
            return x2
        x0,x1=x1,x2
    print("Did not converge within max iterations.")
    return x2


m=185/6
c=1000


##This creates a range of k values to plot

k_values_plot = np.linspace(500, 10000, 100) 


# We use objective(k) which returns (deflection - 0.05)
objective_values = []
for k_val in k_values_plot:
    print(f"Plotting: Trying k={k_val:.0f}")
    objective_values.append(objective(k_val))

#Create the plot
plt.figure(figsize=(10, 6))
plt.plot(k_values_plot, objective_values, 'b-', label='objective(k) [Max Deflection - 0.05 m]')

# Add the target line (where objective = 0)
plt.axhline(y=0.0, color='r', linestyle='--', 
            label='Target (objective = 0)')

#Add labels and title
plt.xlabel('Spring Stiffness $k$ (N/m)')
plt.ylabel('Objective Function Output')
plt.title('Objective Function vs. Stiffness')
plt.legend()
plt.grid(True)
plt.savefig('objective_function_plot.png')

print("Plot 'objective_function_plot.png' saved.")
print("Look at this plot to find where the blue line crosses the red line.")
print("Use k-values on either side of that crossing as your new k0 and k1.")

k0,k1=4000,6000
k_solution= secant(objective,k0,k1)

# Check if the calculated stiffness is within a valid range
k_min, k_max = 1000, 10000  # you can adjust this range for your rover

print("\n" + "-"*60)
print("  FINAL RESULTS — MARS ROVER SUSPENSION TUNING")
print("-"*60)
print(f"Estimated stiffness (k)  ≈ {k_solution:.2f} N/m")
print(f"Damping coefficient (c)  = {c:.2f} Ns/m")
print(f"Mass (m)                 = {m:.2f} kg")

# Check if within range
if k_min <= k_solution <= k_max:
    print(f"! The calculated stiffness lies within the expected range ({k_min}–{k_max} N/m).")
else:
    print(f"! The calculated stiffness is outside the expected range ({k_min}–{k_max} N/m).")
    print("   Please verify your input parameters or root-finding range.")

print("-"*60)
print("Target max deflection: 0.025 m")
print("Simulation & root-finding completed successfully.")
print("-"*60)
print(f"\nEstimated stiffness k ≈ {k_solution:.2f} N/m")



